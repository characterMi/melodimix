importScripts("/appVersion.js");

const assets = [
  "/",
  "/search",
  "/manifest.webmanifest",
  "/cacheWorker.js",
  "/appVersion.js",
  "/logo.svg",
  "/images/1.jpg",
  "/images/2.jpg",
  "/images/d1.png",
  "/images/d2.png",
  "/images/d3.png",
  "/icons/melodimix-192.png",
  "/icons/melodimix-192-maskable.png",
  "/icons/melodimix-512.png",
  "/icons/melodimix-512-maskable.png",
];

const assetsCacheName = "assets~" + VERSION;
const cacheNames = new Set([assetsCacheName, "songs-data", "songs"]);

const SUPABASE_HOSTNAME = "ibmcmrwzbejntporrerq.supabase.co";

self.addEventListener("install", (event) => {
  event.waitUntil(
    (async () => {
      const cache = await caches.open(assetsCacheName);
      await Promise.allSettled(assets.map((url) => cache.add(url)));

      self.skipWaiting();
    })()
  );
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    (async () => {
      // Remove old caches (assets)
      const keys = await caches.keys();
      await Promise.allSettled(
        keys
          .filter((key) => !cacheNames.has(key))
          .map((key) => caches.delete(key))
      );
      await self.clients.claim();
    })()
  );
});

self.addEventListener("message", (event) => {
  // We want to cache missing assets (if there is any) whenever user loads our app.
  if (event.data?.type === "CACHE-MISSING-ASSETS") {
    (async () => {
      try {
        const cache = await caches.open(assetsCacheName);
        const matches = await Promise.all(
          assets.map((asset) => cache.match(asset))
        );

        const missingAssets = assets.filter((_, i) => !matches[i]);

        if (missingAssets.length) {
          await Promise.allSettled(missingAssets.map((url) => cache.add(url)));
        }
      } catch (err) {
        console.error("Error caching missing assets:", err);
      }
    })();
  }
});

self.addEventListener("fetch", (event) => {
  // we don't want to cache any method beside GET...
  if (event.request.method !== "GET") return;

  const eventUrl = new URL(event.request.url);

  if (eventUrl.hostname === SUPABASE_HOSTNAME) {
    // No need to fetch (we handle that in the useLoadSong hook) + don't cache any token...
    if (
      eventUrl.pathname.startsWith("/storage/v1/object/public/songs") ||
      eventUrl.pathname.startsWith("/auth/v1/token")
    )
      return;

    // Song by id...
    if (
      eventUrl.pathname.startsWith("/rest/v1/songs") &&
      eventUrl.searchParams.has("id")
    ) {
      event.respondWith(staleWhileRevalidate(event.request, "songs-data"));
      return;
    }

    event.respondWith(networkFirst(event.request, "songs-data"));
    return;
  }

  // Next.js related things (React server components and client-side navigation)...
  if (eventUrl.searchParams.has("_rsc")) {
    event.respondWith(handleRSC(event.request));
    return;
  }

  // HTML pages, if the requested page is in the cache we respond with it, if not, we respond with the offline page...
  if (
    event.request.mode === "navigate" ||
    event.request.headers.get("accept")?.includes("text/html")
  ) {
    event.respondWith(handleHTML(event.request));
    return;
  }

  // same origin files
  if (eventUrl.host === self.location.host) {
    // static files generated by Next.js (Fonts, CSS, JS) + cached files in assets
    if (
      eventUrl.pathname.startsWith("/_next/static") ||
      assets.includes(eventUrl.pathname)
    ) {
      event.respondWith(cacheOnly(event.request, assetsCacheName));
      return;
    }

    // images generated by Next.js
    if (eventUrl.pathname.startsWith("/_next/image")) {
      event.respondWith(staleWhileRevalidate(event.request, assetsCacheName));
      return;
    }
  }

  // other requests...
  event.respondWith(networkFirst(event.request, assetsCacheName));
});

async function cacheOnly(req, cacheName) {
  const cache = await caches.open(cacheName);
  const cachedResponse = await cache.match(req);

  if (cachedResponse) {
    return cachedResponse.clone();
  }

  return fetchReq(req, cache);
}

async function staleWhileRevalidate(req, cacheName) {
  const cache = await caches.open(cacheName);
  const cachedResponse = await cache.match(req);
  const fetchRes = fetchReq(req, cache);

  if (cachedResponse) {
    return cachedResponse.clone();
  }

  return fetchRes;
}

async function networkFirst(req, cacheName, isRequestingHTML = false) {
  const cache = await caches.open(cacheName);
  const fetchRes = await fetchReq(req, cache);

  if (fetchRes) return fetchRes;

  const cachedResponse = await cache.match(req);

  if (cachedResponse) return cachedResponse.clone();

  return isRequestingHTML ? offlineHTMLFallback() : responseFallback();
}

async function fetchReq(req, cache) {
  return fetch(req, { cache: "no-cache" })
    .then(async (networkRes) => {
      if (networkRes.ok) await cache.put(req, networkRes.clone());
      return networkRes;
    })
    .catch(() => responseFallback());
}

async function handleRSC(req) {
  // Requesting for shell html page and caching it...
  const htmlUrl = new URL(req.url);
  htmlUrl.search = htmlUrl.hash = "";
  const cache = await caches.open(assetsCacheName);
  fetchReq(htmlUrl.toString(), cache);

  // rsc request
  return networkFirst(req, assetsCacheName);
}

async function handleHTML(req) {
  const requestedUrl = new URL(req.url);

  const hasSearch = requestedUrl.searchParams.size > 0;
  const hasHash = requestedUrl.hash !== "";

  // handling requests with search params and hash...
  if (hasSearch || hasHash) {
    const htmlResponse = await fetchReq(req);
    if (htmlResponse) return htmlResponse;

    requestedUrl.search = requestedUrl.hash = "";

    const cache = await caches.open(assetsCacheName);
    const cachedResponse = await cache.match(requestedUrl.toString(), {
      ignoreSearch: true,
    });

    if (cachedResponse) return cachedResponse.clone();

    return offlineHTMLFallback();
  }

  return networkFirst(req, assetsCacheName, /* isRequestingHTML= */ true);
}

function responseFallback() {
  return new Response(
    "Network error and no cached data available. see the browser's console for more information",
    {
      status: 503,
      statusText: "Service Unavailable.",
      headers: { "Content-Type": "text/plain" },
    }
  );
}

function offlineHTMLFallback() {
  return new Response(
    `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport"content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover"/><link rel="icon" href="/icons/melodimix-192.png"/><link rel="apple-touch-icon" href="/icons/melodimix-192.png"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="description"content="You're offline, check your internet connection and try again."/><meta name="theme-color"content="#065f46"/><meta name="color-scheme"content="dark"/><title>You're offline )):</title><style>body{background-color:black;font-family:Arial,Helvetica,sans-serif;display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;height:100svh;margin:0;padding:0 1rem;overscroll-behavior:none;user-select:none;-webkit-user-select:none;user-drag:none;-webkit-user-drag:none;touch-callout:none;-webkit-touch-callout:none;}div{display:flex;align-items:center;gap:10px;}button{padding:0.75rem;border-radius:999px;background-color:#22c55e;color:black;border:none;cursor:pointer;transition:opacity 0.3s ease;font-size:1.2rem;font-weight:bold;margin-top:10px;-webkit-tap-highlight-color:transparent;}button:hover{opacity:0.75;}button:focus-visible{opacity: 0.75;outline: none;}</style></head><body><div><h1>You're currently <span style="color:#065f46">offline.</span></h1><svg stroke="white"fill="none"stroke-width="2"viewBox="0 0 24 24" aria-hidden="true"style="min-width:3.5rem;min-height:3.5rem"width="3.5rem"height="3.5rem"xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round"stroke-linejoin="round"d="M18.364 5.636a9 9 0 010 12.728m0 0l-2.829-2.829m2.829 2.829L21 21M15.536 8.464a5 5 0 010 7.072m0 0l-2.829-2.829m-4.243 2.829a4.978 4.978 0 01-1.414-2.83m-1.414 5.658a9 9 0 01-2.167-9.238m7.824 2.167a1 1 0 111.414 1.414m-1.414-1.414L3 3m8.293 8.293l1.414 1.414"></path></svg></div><p>it looks like you're offline, Unfortunately we haven't cached this page, so make sure you're online and try again.</p><button onclick="window.location.reload()">Reload</button></body></html>`,
    {
      status: 503,
      statusText: "Service Unavailable.",
      headers: { "Content-Type": "text/html" },
    }
  );
}
