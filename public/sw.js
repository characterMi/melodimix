importScripts("/appVersion.js");

const assets = [
  "/",
  "/search",
  "/offline.html",
  "/manifest.webmanifest",
  "/cacheWorker.js",
  "/appVersion.js",
  "/logo.svg",
  "/icons/offline.png",
  "/images/liked.png",
  "/images/1.jpg",
  "/images/2.jpg",
  "/images/d1.png",
  "/images/d2.png",
  "/images/d3.png",
  "/icons/melodimix-192.png",
  "/icons/melodimix-192-maskable.png",
  "/icons/melodimix-512.png",
  "/icons/melodimix-512-maskable.png",
];

const assetsCacheName = "assets" + VERSION;
const cacheNames = new Set([assetsCacheName, "song-urls", "songs"]);

const SUPABASE_HOSTNAME = "ibmcmrwzbejntporrerq.supabase.co";

self.addEventListener("install", (event) => {
  event.waitUntil(
    (async () => {
      const cache = await caches.open(assetsCacheName);
      await Promise.allSettled(assets.map((url) => cache.add(url)));

      self.skipWaiting();
    })()
  );
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches
      .keys()
      .then((keys) =>
        Promise.allSettled([
          ...keys
            .filter((key) => !cacheNames.has(key))
            .map((key) => caches.delete(key)),
          self.clients.claim(),
        ])
      )
  );
});

self.addEventListener("fetch", (event) => {
  const eventUrl = new URL(event.request.url);

  // caching songs and song-urls from supabase
  if (eventUrl.hostname === SUPABASE_HOSTNAME) {
    if (eventUrl.pathname.startsWith("/rest/v1/songs")) {
      event.respondWith(cacheOnly(event.request, "song-urls"));
      return;
    }

    if (eventUrl.pathname.startsWith("/storage/v1/object/public/songs")) {
      event.respondWith(cacheOnly(event.request, "songs"));
      return;
    }

    // don't cache any token or liked songs (strange behavior when we cache liked songs)...
    if (
      eventUrl.pathname.startsWith("/auth/v1/token") ||
      eventUrl.pathname.startsWith("/rest/v1/liked_songs")
    ) {
      event.respondWith(fetchReq(event.request));
      return;
    }
  }

  // Next.js related things... (i don't even know what they are, i just know they ruin my app)
  if (eventUrl.searchParams.has("_rsc")) {
    event.respondWith(fetchReq(event.request));
    return;
  }

  // HTML files, if the requested page is in the cache we respond with it, if not, we respond with the offline page...
  if (
    event.request.mode === "navigate" ||
    event.request.headers.get("accept")?.includes("text/html")
  ) {
    event.respondWith(
      staleWhileRevalidate(event.request, assetsCacheName, true)
    );
    return;
  }

  // static files
  if (eventUrl.host === self.location.host) {
    // static files generated by Next.js
    // (Fonts)
    if (eventUrl.pathname.startsWith("/_next/static/media")) {
      event.respondWith(cacheOnly(event.request, assetsCacheName));
      return;
    }

    // (CSS, JS)
    if (eventUrl.pathname.startsWith("/_next/static")) {
      event.respondWith(staleWhileRevalidate(event.request, assetsCacheName));
      return;
    }

    // images generated by Next.js
    if (eventUrl.pathname.startsWith("/_next/image")) {
      event.respondWith(cacheOnly(event.request, assetsCacheName));
      return;
    }

    // cached files in assets
    if (assets.includes(eventUrl.pathname)) {
      event.respondWith(cacheOnly(event.request, assetsCacheName));
      return;
    }
  }

  // other requests...
  if (event.request.method === "GET") {
    event.respondWith(staleWhileRevalidate(event.request, assetsCacheName));
    return;
  }

  // we don't cache any other method...
  event.respondWith(fetchReq(event.request));
});

async function cacheOnly(req, cacheName) {
  const cache = await caches.open(cacheName);
  const cachedResponse = await cache.match(req);

  if (cachedResponse) {
    return cachedResponse.clone();
  }

  return fetchReq(req, cache);
}

async function staleWhileRevalidate(req, cacheName, returnOffline = false) {
  // if the request was for a html page, we ignore search params...
  const cacheProps = returnOffline ? { ignoreSearch: true } : undefined;
  const cache = await caches.open(cacheName);
  const cachedResponse = await cache.match(req, cacheProps);
  const fetchRes = await fetchReq(req, cache, returnOffline);

  return cachedResponse || fetchRes;
}

async function fetchReq(req, cache = null, returnOffline = false) {
  return fetch(req, { cache: "no-cache" })
    .then(async (networkRes) => {
      if (cache && networkRes.ok) await cache.put(req, networkRes.clone());
      return networkRes;
    })
    .catch(async () => {
      if (returnOffline) {
        const assetsCache = await caches.open(assetsCacheName);
        const offlinePage = await assetsCache.match("/offline.html");

        if (offlinePage) return offlinePage;

        console.warn("Offline page not found in cache");
      }

      return new Response(
        "Network error and no cached data available. see the browser's console for more information",
        {
          status: 503,
          statusText: "Service Unavailable.",
          headers: { "Content-Type": "text/plain" },
        }
      );
    });
}
